import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/atomic-spinner/lib/index.esm.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var ElectronPath = function(_a) {
  var pathDefinitionId = _a.pathDefinitionId, color = _a.color, width = _a.width, rotationAngle = _a.rotationAngle;
  return React.createElement(
    "g",
    { transform: "rotate(".concat(rotationAngle, " 50 50)") },
    React.createElement("use", { href: "#".concat(pathDefinitionId), stroke: color, strokeWidth: width })
  );
};
var Electron = function(_a) {
  var pathDefinitionId = _a.pathDefinitionId, rotationAngle = _a.rotationAngle, orbitTime = _a.orbitTime, spacetimeOffset = _a.spacetimeOffset, size = _a.size, color = _a.color;
  return React.createElement(
    "g",
    { "data-testid": "electron", transform: "rotate(".concat(rotationAngle, " 50 50)") },
    React.createElement(
      "circle",
      { cx: "50", cy: "15", r: size, fill: color },
      React.createElement(
        "animateMotion",
        { dur: "".concat(orbitTime, "s"), repeatCount: "indefinite", begin: "".concat(spacetimeOffset, "s") },
        React.createElement("mpath", { href: "#".concat(pathDefinitionId) })
      )
    )
  );
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var NucleusLayer = function(_a) {
  var particleFillColor = _a.particleFillColor, particleBorderColor = _a.particleBorderColor, particleBorderWidth = _a.particleBorderWidth, particlesPerLayer = _a.particlesPerLayer, particleSize = _a.particleSize, distanceFromCenter = _a.distanceFromCenter, orbitTime = _a.orbitTime, startingAngle = _a.startingAngle, nucleusMaskOverlap = _a.nucleusMaskOverlap;
  var particles = Array.from({ length: particlesPerLayer }).map(function(_, i) {
    var rotationAngle = startingAngle + i * (2 * Math.PI / particlesPerLayer);
    var offsetX = particlesPerLayer > 1 ? distanceFromCenter * Math.cos(rotationAngle) : 0;
    var offsetY = particlesPerLayer > 1 ? distanceFromCenter * Math.sin(rotationAngle) : 0;
    var particleDimensions = {
      cx: 50 + offsetX,
      cy: 50 + offsetY
    };
    var effectiveBorderWidth = Math.min(particleBorderWidth, particleSize / 3);
    return React.createElement(
      React.Fragment,
      { key: "particle-".concat(rotationAngle) },
      nucleusMaskOverlap && effectiveBorderWidth > 0 && i === 0 && React.createElement(
        "mask",
        { id: "layer-".concat(startingAngle, "-bottom-particle") },
        React.createElement("rect", { x: "0", y: "0", width: "100", height: "100", fill: "white" }),
        React.createElement("circle", __assign({}, particleDimensions, { r: particleSize + effectiveBorderWidth / 2 }))
      ),
      React.createElement("circle", __assign({}, particleDimensions, { r: particleSize, fill: particleFillColor, stroke: particleBorderColor, strokeWidth: effectiveBorderWidth, mask: nucleusMaskOverlap && i > Math.floor(particlesPerLayer / 2) ? "url('#layer-".concat(startingAngle, "-bottom-particle')") : void 0 }))
    );
  });
  return React.createElement(
    "g",
    null,
    React.createElement("animateTransform", { attributeName: "transform", begin: "0s", dur: "".concat(orbitTime, "s"), type: "rotate", from: "0 50 50", to: "360 50 50", repeatCount: "indefinite" }),
    particles
  );
};
var Nucleus = function(props) {
  var angleIncrement = props.particlesPerLayer % 2 === 0 ? Math.PI / 2 / Math.max(1, props.layerCount - 1) : Math.PI / Math.max(1, props.layerCount - 1);
  return React.createElement(React.Fragment, null, Array.from({ length: props.layerCount }).map(function(_, index2) {
    var startingAngle = index2 * angleIncrement;
    return React.createElement(NucleusLayer, __assign({ key: "nucleus-layer-".concat(startingAngle) }, props, { particlesPerLayer: props.particlesPerLayer, startingAngle }));
  }));
};
var AtomicSpinner = function(_a) {
  var _b = _a.atomSize, atomSize = _b === void 0 ? 200 : _b, _c = _a.displayElectronPaths, displayElectronPaths = _c === void 0 ? true : _c, _d = _a.displayNucleus, displayNucleus = _d === void 0 ? true : _d, _e = _a.electronColorPalette, electronColorPalette = _e === void 0 ? ["#0081C9", "#5BC0F8", "#86E5FF"] : _e, _f = _a.electronPathCount, electronPathCount = _f === void 0 ? 3 : _f, _g = _a.electronPathColor, electronPathColor = _g === void 0 ? "#707070" : _g, _h = _a.electronPathWidth, electronPathWidth = _h === void 0 ? 0.5 : _h, _j = _a.electronsPerPath, electronsPerPath = _j === void 0 ? 2 : _j, _k = _a.electronSize, electronSize = _k === void 0 ? 1.5 : _k, _l = _a.electronSpeed, electronSpeed = _l === void 0 ? 0.5 : _l, _m = _a.nucleusLayerCount, nucleusLayerCount = _m === void 0 ? 2 : _m, _o = _a.nucleusParticlesPerLayer, nucleusParticlesPerLayer = _o === void 0 ? 3 : _o, _p = _a.nucleusParticleFillColor, nucleusParticleFillColor = _p === void 0 ? "#707070" : _p, _q = _a.nucleusParticleBorderColor, nucleusParticleBorderColor = _q === void 0 ? "#999999" : _q, _r = _a.nucleusParticleBorderWidth, nucleusParticleBorderWidth = _r === void 0 ? 0.3 : _r, _s = _a.nucleusParticleSize, nucleusParticleSize = _s === void 0 ? 2.5 : _s, _t = _a.nucleusDistanceFromCenter, nucleusDistanceFromCenter = _t === void 0 ? 2.5 : _t, _u = _a.nucleusSpeed, nucleusSpeed = _u === void 0 ? 2 : _u, _v = _a.nucleusMaskOverlap, nucleusMaskOverlap = _v === void 0 ? true : _v;
  var electronPaths = Array.from({ length: electronPathCount }).map(function(_, i) {
    return {
      rotationAngle: 0 + i * (180 / electronPathCount),
      electronCount: electronsPerPath,
      electronOrbitTime: 1 / electronSpeed + Math.random() * (0.2 / electronSpeed)
    };
  });
  var electronPathDefinitionId = "electronPath";
  var electronDefinitionId = "electron";
  var colorOffset = Math.floor(Math.random() * electronColorPalette.length);
  return React.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: atomSize, height: atomSize, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid" },
    React.createElement(
      "defs",
      null,
      React.createElement("path", { id: electronPathDefinitionId, d: "M50 15A15 35 0 0 1 50 85A15 35 0 0 1 50 15", fill: "none" }),
      React.createElement("path", { id: electronDefinitionId, d: "M0 0A15 35 0 0 1 0 70A15 35 0 0 1 0 0", fill: "none" })
    ),
    displayNucleus && React.createElement(Nucleus, { layerCount: nucleusLayerCount, particlesPerLayer: nucleusParticlesPerLayer, particleSize: nucleusParticleSize, distanceFromCenter: nucleusDistanceFromCenter, particleFillColor: nucleusParticleFillColor, particleBorderColor: nucleusParticleBorderColor, particleBorderWidth: nucleusParticleBorderWidth, orbitTime: 10 / nucleusSpeed, nucleusMaskOverlap }),
    displayElectronPaths && electronPaths.map(function(_a2) {
      var rotationAngle = _a2.rotationAngle;
      return React.createElement(ElectronPath, { key: "electron-path-".concat(rotationAngle), pathDefinitionId: electronPathDefinitionId, color: electronPathColor, width: electronPathWidth, rotationAngle });
    }),
    electronPaths.map(function(_a2, pathIndex) {
      var electronCount = _a2.electronCount, rotationAngle = _a2.rotationAngle, electronOrbitTime = _a2.electronOrbitTime;
      var randomSpacetimeShift = (-1 + Math.random() * -1) * electronOrbitTime;
      return Array.from({ length: electronCount }).map(function(_, electronIndex) {
        var _a3;
        var electronKey = electronIndex;
        return React.createElement(Electron, { key: "electron-".concat(electronKey), pathDefinitionId: electronDefinitionId, rotationAngle, orbitTime: electronOrbitTime, size: electronSize, spacetimeOffset: randomSpacetimeShift + electronIndex * (electronOrbitTime / electronCount), color: (_a3 = electronColorPalette[(pathIndex * electronsPerPath + electronIndex + colorOffset) % electronColorPalette.length]) !== null && _a3 !== void 0 ? _a3 : "#000" });
      });
    })
  );
};
var index = import_react.default.memo(AtomicSpinner);
export {
  index as default
};
//# sourceMappingURL=atomic-spinner.js.map
